G <- dim(M)[2]  # patients
div <- rep(0,length(seed)) # vector of different GKLD values
Plist <- list()            # list of P matrices
Elist <- list()            # list of E matrices
reslist <- list()
poisson_em = function(x){
x = exp(x)
P = matrix(x[1:(K*N)], nrow = K, ncol = N)
E = matrix(x[-c(1:(K*N))], nrow = N, ncol = G)
PE <- P%*%E
P <- P * ((M/PE) %*% t(E))      # update of signatures
P <- P %*% diag(1/colSums(P))   # make sure the columns sum to one
PE <- P%*%E
E <- E * (t(P) %*% (M/PE))      # update of exposures
par = c(as.vector(P),as.vector(E))
par[par <= 0] = 1e-10
return(log(par))
}
gklobj = function(x){
x = exp(x)
P = matrix(x[1:(K*N)], nrow = K, ncol = N)
E = matrix(x[-c(1:(K*N))], nrow = N, ncol = G)
GKL <- gklDiv(as.vector(M),as.vector(P%*%E)) # GKLD value
return(GKL)
}
for(i in 1:length(seed)){
set.seed(seed[i])
P <- matrix(runif(K*N), nrow = K, ncol = N)  # Initialize P
E <- matrix(runif(N*G), nrow = N, ncol = G)  # Initialize E
init = log(c(as.vector(P),as.vector(E)))
sres = squarem(init, fixptfn = poisson_em, objfn = gklobj, control = list(tol = tol))
P = matrix(exp(sres$par[1:(K*N)]), nrow = K, ncol = N)
E = matrix(exp(sres$par[-c(1:(K*N))]), nrow = N, ncol = G)
Plist[[i]] <- P # signatures
Elist[[i]] <- E # exposures
div[i] <- gklobj(sres$par)   # final generalized Kullback-Leibler divergence
reslist[[i]] = sres
}
best <- which.min(div) # Smallest GKLD value
P = Plist[[best]]
E = Elist[[best]]
Output <- list()
Output$P <-  P
Output$E <-  E
Output$gkl <- div[best]
Output$results <- reslist
return(Output)
}
gklDiv <- function(y, mu){
r <- mu
p <- which(y > 0)
r[p] <- (y * (log(y)- log(mu)) - y + mu)[p]
return(sum(r))
}
alphaNR2(SimulatedDataNBalpha200[[1]], 5)
library(SQUAREM)
alphaNR2(SimulatedDataNBalpha200[[1]], 5)
data=t(SimulatedDataNBalpha200[[1]])
k=5
res_p <- NMFPois(data,k,tol = 1e-2,
seed = sample(100000,1))
h_p <- res_p$P
w_p <- res_p$E
# differentiated once
neglikdiff1 = function(alpha, data, estimate){
sum(digamma(data + alpha) - digamma(alpha) - data/(alpha+estimate) - alpha/(alpha+estimate) + log(alpha/(alpha+estimate)) + 1)
}
# differentiated twice
neglikdiff2 = function(alpha, data, estimate){
sum(trigamma(data + alpha) - trigamma(alpha) + data/(alpha+estimate)^2 + 1/alpha - 2/(alpha+estimate) + alpha/(alpha+estimate)^2)
}
NR_alpha = function(data,estimate){
alpha <- 1/var(data/estimate)
alphaold = alpha + 5
for(i in 1:10){
alpha = alpha - neglikdiff1(alpha, data = data, estimate = estimate)/neglikdiff2(alpha, data = data, estimate = estimate)
if(!(alpha > 0)){ alpha = runif(1,1,10)}
if(abs(alpha - alphaold) < 0.01) break
alphaold = alpha
}
return(alpha)
}
data
dim(data)
dim(w_p%*%h_p)
alpha <- alphaNR(t(SimulatedDataNBalpha200[[1]]),5)
#' @param data Numeric matrix of mutational counts data. Matrix size: no. of patients x no. of mutation types.
#' @param k Number of signatures to be used for the non-negative matrix factorization
#' @param patient_specific Logical. If TRUE patient-specific overdispersion is used in the Negative Binomial model.
#'
#'
#' @return Overdispersion parameter. Either vector of length one or vector of length no. of patients if patient-specific overdispersion is used.
#'
#' @export
#'
#'
alphaNR3 <- function(data, k=NULL, patient_specific = FALSE){
if (k!=round(k)){
stop("The number of signatures must be an integer.")
}
if(is.null(data)){
stop("The data set of the mutational counts is missing.")
}
data <- t(data)
if(is.null(k)){
stop("A value for the number of signatures to be estimated is missing.")
}
if(length(k)!=1){
stop("'k' has length larger than 1.")
}
res_p <- NMFPois(data,k,tol = 1e-2,
seed = sample(100000,1))
h_p <- res_p$P
w_p <- res_p$E
# differentiated once
neglikdiff1 = function(alpha, data, estimate){
sum(digamma(data + alpha) - digamma(alpha) - data/(alpha+estimate) - alpha/(alpha+estimate) + log(alpha/(alpha+estimate)) + 1)
}
# differentiated twice
neglikdiff2 = function(alpha, data, estimate){
sum(trigamma(data + alpha) - trigamma(alpha) + data/(alpha+estimate)^2 + 1/alpha - 2/(alpha+estimate) + alpha/(alpha+estimate)^2)
}
NR_alpha = function(data,estimate){
alpha <- 1/var(data/estimate)
alphaold = alpha + 5
for(i in 1:10){
alpha = alpha - neglikdiff1(alpha, data = data, estimate = estimate)/neglikdiff2(alpha, data = data, estimate = estimate)
if(!(alpha > 0)){ alpha = runif(1,1,10)}
if(abs(alpha - alphaold) < 0.01) break
alphaold = alpha
}
return(alpha)
}
if(patient_specific){
alpha = numeric(ncol(data))
estimate = w_p%*%h_p
for(i in 1:ncol(data)){
alpha[i] = NR_alpha(data[,i],estimate[,i])
}
}else{
data = as.vector(data)
estimate = as.vector(w_p%*%h_p)
alpha = NR_alpha(data,estimate)
}
return(alpha)
}
alpha <- alphaNR3(t(SimulatedDataNBalpha200[[1]]),5)
alpha
alphaNR2(SimulatedDataNBalpha200[[1]], 5)
alphaNR2(SimulatedDataNBalpha200[[1]], 5)
remove.packages("SigMoS", lib="~/R/x86_64-pc-linux-gnu-library/4.2")
devtools::install_github("MartaPelizzola/SigMoS")
library(SigMoS)
res <- NMFPois(t(SimulatedDataNBalpha200[[1]]),5)
res2 <-  sigmos(t(SimulatedDataNBalpha200[[1]]),k=5,method = "Poisson")
dim(BRCA21)
res2 <-  sigmos(t(BRCA21),k=5,method = "Poisson")
barpot(res2$Signatures[1,])
res2 <-  sigmos(t(BRCA21),k=3,method = "Poisson")
par(mfrow=c(2,2))
barplot(res2$Signatures[1,])
barplot(res2$Signatures[2,])
barplot(res2$Signatures[3,])
alpha <- alphaNR(t(BRCA21),3)
res3 <- NMFNB(t(BRCA21),3, alpha)
barplot(res3$Signatures[1,])
res3$E
barplot(res3$E[,1])
barplot(res3$E[,2])
barplot(res3$E[,3])
barplot(res3$E[,1])
barplot(res3$E[,2])
barplot(res3$E[,1])
barplot(res3$E[,2])
barplot(res3$E[,3])
barplot(res3$P[3,])
barplot(res3$P[1,])
barplot(res3$P[2,])
barplot(res3$P[3,])
res4 <-  sigmos(t(BRCA21),k=3,method = "NB")
alpha <- alphaNR(data,k,patient_specific)
data=t(BRCA21)
k=3
patient_specific=F
alpha <- alphaNR(data,k,patient_specific)
res_nb <- NMFNB(M=data, N=k, alpha = alpha, tol = tol, seed = sample(1:1000,5))
tol=1e-5
res_nb <- NMFNB(M=data, N=k, alpha = alpha, tol = tol, seed = sample(1:1000,5))
cores=detectCores()
cl <- makeCluster(cores[1]-1)
library()
library(foreach)
library(parallel)
library(doParallel)
cores=detectCores()
cl <- makeCluster(cores[1]-1)
registerDoParallel(cl)
cost <- foreach(i=1:n_iterations, .combine=c, .packages=c('SQUAREM'), .export = ls(globalenv())) %dopar% {
set.seed(i)
n <- nrow(data)
train_set = sample(1:n, size_train*n)
if(patient_specific){
res_train <- NMFNB(M=data[train_set,], N=k, alpha = alpha[train_set], tol = tol)
}else{
res_train <- NMFNB(M=data[train_set,], N=k, alpha = alpha, tol = tol)
}
h_train <- res_train$P
ord = corSig(h_train,res_nb$P)$match
if (cost_f=="GKL"){
tmp_cost <- gklDiv(as.vector(data[-train_set,]), as.vector(res_nb$E[-train_set,ord] %*% h_train))
} else if (cost_f=="Frobenius"){
tmp_cost = sqrt(sum((data[-train_set,]-(res_nb$E[-train_set,ord] %*% h_train))^2))
} else if (cost_f=="IS"){
a_div = as.vector(data[-train_set,])
b_div = as.vector(res_nb$E[-train_set,ord] %*% h_train)
zeros <- which(a_div>0)
tmp_costIS <- b_div
tmp_costIS[zeros] <- (a_div/b_div - log(a_div/b_div))[zeros]
tmp_cost <- sum(tmp_costIS)
} else {
warning(paste0("The tmp_cost function ", cost_f, "is not implemented. Generalized Kullback-Leibler will be used."))
tmp_cost <- gklDiv(as.vector(data[-train_set,]), as.vector(res_nb$E[-train_set,ord] %*% h_train))
}
tmp_cost
}
n_iterations=100
cost <- foreach(i=1:n_iterations, .combine=c, .packages=c('SQUAREM'), .export = ls(globalenv())) %dopar% {
set.seed(i)
n <- nrow(data)
train_set = sample(1:n, size_train*n)
if(patient_specific){
res_train <- NMFNB(M=data[train_set,], N=k, alpha = alpha[train_set], tol = tol)
}else{
res_train <- NMFNB(M=data[train_set,], N=k, alpha = alpha, tol = tol)
}
h_train <- res_train$P
ord = corSig(h_train,res_nb$P)$match
if (cost_f=="GKL"){
tmp_cost <- gklDiv(as.vector(data[-train_set,]), as.vector(res_nb$E[-train_set,ord] %*% h_train))
} else if (cost_f=="Frobenius"){
tmp_cost = sqrt(sum((data[-train_set,]-(res_nb$E[-train_set,ord] %*% h_train))^2))
} else if (cost_f=="IS"){
a_div = as.vector(data[-train_set,])
b_div = as.vector(res_nb$E[-train_set,ord] %*% h_train)
zeros <- which(a_div>0)
tmp_costIS <- b_div
tmp_costIS[zeros] <- (a_div/b_div - log(a_div/b_div))[zeros]
tmp_cost <- sum(tmp_costIS)
} else {
warning(paste0("The tmp_cost function ", cost_f, "is not implemented. Generalized Kullback-Leibler will be used."))
tmp_cost <- gklDiv(as.vector(data[-train_set,]), as.vector(res_nb$E[-train_set,ord] %*% h_train))
}
tmp_cost
}
res4 <-  sigmos(t(BRCA21),k=3,method = "NB")
barplot(res3$P[3,])
par(mfrow=c(2,2))
barplot(res4$P[1,])
barplot(res4$Signatures[1,])
barplot(res4$Signatures[2,])
barplot(res4$Signatures[3,])
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2)
#' @param data Numeric matrix of mutational counts data. Matrix size: no. of mutation types x no. of patients.
#' @param k Number of signatures to be used for the non-negative matrix factorization
#' @param patient_specific Logical. If TRUE patient-specific overdispersion is used in the Negative Binomial model.
#'
#'
#' @return Overdispersion parameter. Either vector of length one or vector of length no. of patients if patient-specific overdispersion is used.
#'
#' @export
#'
#'
alphaNR2 <- function(data, k=NULL, patient_specific = FALSE){
if (k!=round(k)){
stop("The number of signatures must be an integer.")
}
if(is.null(data)){
stop("The data set of the mutational counts is missing.")
}
if(is.null(k)){
stop("A value for the number of signatures to be estimated is missing.")
}
if(length(k)!=1){
stop("'k' has length larger than 1.")
}
res_p <- NMFPoisEM(data,k,tol = 1e-2,
seed = sample(100000,1))
h_p <- res_p$P
w_p <- res_p$E
# differentiated once
neglikdiff1 = function(alpha, data, estimate){
sum(digamma(data + alpha) - digamma(alpha) - data/(alpha+estimate) - alpha/(alpha+estimate) + log(alpha/(alpha+estimate)) + 1)
}
# differentiated twice
neglikdiff2 = function(alpha, data, estimate){
sum(trigamma(data + alpha) - trigamma(alpha) + data/(alpha+estimate)^2 + 1/alpha - 2/(alpha+estimate) + alpha/(alpha+estimate)^2)
}
NR_alpha = function(data,estimate){
alpha <- 1/var(data/estimate)
alphaold = alpha + 5
for(i in 1:10){
alpha = alpha - neglikdiff1(alpha, data = data, estimate = estimate)/neglikdiff2(alpha, data = data, estimate = estimate)
if(!(alpha > 0)){ alpha = runif(1,1,10)}
if(abs(alpha - alphaold) < 0.01) break
alphaold = alpha
}
return(alpha)
}
if(patient_specific){
alpha = numeric(ncol(data))
estimate = h_p%*%w_p
for(i in 1:ncol(data)){
alpha[i] = NR_alpha(data[,i],estimate[,i])
}
}else{
data = as.vector(data)
estimate = as.vector(h_p%*%w_p)
alpha = NR_alpha(data,estimate)
}
return(alpha)
}
alphaO <- alphaNR2(BRCA21,5, patient_specific = T)
#' @import SQUAREM
#' @title Poisson non-negative matrix factorization
#'
#' @description EM algorithm for poisson non-negative matrix factorization
#'
#'
#' @param M Numeric matrix of mutational counts data. Matrix size: no. of mutation types x no. of patients.
#' @param N Integer. Number of signatures to be used for matrix factorization.
#' @param tol Threshold for convergence of the EM algorithm for estimating mutational signatures. Default is 1e-5.
#' @param seed Vector of seeds for initializing the values of the signatures and exposures matrices. If default only one initialization is performed.
#'
#'
#' @return List of non-negative matrix factorization results. P is the signature matrix and E is the exposures matrix
#'
#' @export
#'
#'
NMFPoisEM = function(M,N=NULL, tol = 1e-5, seed = sample(1:1000,1)){
if (N!=round(N)){
stop("The number of signatures must be an integer.")
}
if(is.null(M)){
stop("The data set of the mutational counts is missing.")
}
if(is.null(N)){
stop("A value for the number of signatures to be estimated is missing.")
}
if(length(N)!=1){
stop("More than one value for the number of signatures is used as input. NB-NMF can only be performed for one value of 'N' at a time.")
}
K <- dim(M)[1]  # mutations
G <- dim(M)[2]  # patients
div <- rep(0,length(seed)) # vector of different GKLD values
Plist <- list()            # list of P matrices
Elist <- list()            # list of E matrices
reslist <- list()
poisson_em = function(x){
x = exp(x)
P = matrix(x[1:(K*N)], nrow = K, ncol = N)
E = matrix(x[-c(1:(K*N))], nrow = N, ncol = G)
PE <- P%*%E
P <- P * ((M/PE) %*% t(E))      # update of signatures
P <- P %*% diag(1/colSums(P))   # make sure the columns sum to one
PE <- P%*%E
E <- E * (t(P) %*% (M/PE))      # update of exposures
par = c(as.vector(P),as.vector(E))
par[par <= 0] = 1e-10
return(log(par))
}
gklobj = function(x){
x = exp(x)
P = matrix(x[1:(K*N)], nrow = K, ncol = N)
E = matrix(x[-c(1:(K*N))], nrow = N, ncol = G)
GKL <- gklDiv(as.vector(M),as.vector(P%*%E)) # GKLD value
return(GKL)
}
for(i in 1:length(seed)){
set.seed(seed[i])
P <- matrix(runif(K*N), nrow = K, ncol = N)  # Initialize P
E <- matrix(runif(N*G), nrow = N, ncol = G)  # Initialize E
init = log(c(as.vector(P),as.vector(E)))
sres = squarem(init, fixptfn = poisson_em, objfn = gklobj, control = list(tol = tol))
P = matrix(exp(sres$par[1:(K*N)]), nrow = K, ncol = N)
E = matrix(exp(sres$par[-c(1:(K*N))]), nrow = N, ncol = G)
Plist[[i]] <- P # signatures
Elist[[i]] <- E # exposures
div[i] <- gklobj(sres$par)   # final generalized Kullback-Leibler divergence
reslist[[i]] = sres
}
best <- which.min(div) # Smallest GKLD value
P = Plist[[best]]
E = Elist[[best]]
Output <- list()
Output$P <-  P
Output$E <-  E
Output$gkl <- div[best]
Output$results <- reslist
return(Output)
}
gklDiv <- function(y, mu){
r <- mu
p <- which(y > 0)
r[p] <- (y * (log(y)- log(mu)) - y + mu)[p]
return(sum(r))
}
alphaO <- alphaNR2(BRCA21,5, patient_specific = T)
library(SQUAREM)
alphaO <- alphaNR2(BRCA21,5, patient_specific = T)
alphaO
hist(alpha2)
hist(alphaO)
length(alpha2)
data=t(BRCA21)
k=3
patient_specific=T
data <- t(data)
res_p <- NMFPois(data,k,tol = 1e-2,
seed = sample(100000,1))
h_p <- res_p$P
w_p <- res_p$E
# differentiated once
neglikdiff1 = function(alpha, data, estimate){
sum(digamma(data + alpha) - digamma(alpha) - data/(alpha+estimate) - alpha/(alpha+estimate) + log(alpha/(alpha+estimate)) + 1)
}
# differentiated twice
neglikdiff2 = function(alpha, data, estimate){
sum(trigamma(data + alpha) - trigamma(alpha) + data/(alpha+estimate)^2 + 1/alpha - 2/(alpha+estimate) + alpha/(alpha+estimate)^2)
}
NR_alpha = function(data,estimate){
alpha <- 1/var(data/estimate)
alphaold = alpha + 5
for(i in 1:10){
alpha = alpha - neglikdiff1(alpha, data = data, estimate = estimate)/neglikdiff2(alpha, data = data, estimate = estimate)
if(!(alpha > 0)){ alpha = runif(1,1,10)}
if(abs(alpha - alphaold) < 0.01) break
alphaold = alpha
}
return(alpha)
}
alpha = numeric(ncol(data))
estimate = w_p%*%h_p
for(i in 1:ncol(data)){
alpha[i] = NR_alpha(data[,i],estimate[,i])
}
hist(alpha)
alpha = numeric(ncol(data))
estimate = w_p%*%h_p
for(i in 1:ncol(data)){
alpha[i] = NR_alpha(data[,i],estimate[,i])
}
hist(alpha)
dim(w_p%*%h_p)
dim(data)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 10000)
length(apha2)
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 10000)
length(alpha2)
hist(alpha2, breaks = 10000, xlim=c(0,50000))
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 10000, xlim=c(0,50000))
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 1000, xlim=c(0,1000))
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 1000, xlim=c(0,1000))
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 1000, xlim=c(0,1000))
length(alpha2)
alpha2 <- alphaNR(t(BRCA21),5, patient_specific = T)
hist(alpha2, breaks = 1000, xlim=c(0,1000))
res4 <- NMFNB(t(BRCA21),5, alpha2, patient_specific = T)
res4 <- NMFNB(t(BRCA21),5, alpha2)
res5 <- NMFNB(t(BRCA21),5, alpha2)
par(mfrow=c(2,2))
barplot(res5$P[1,])
barplot(res5$P[2,])
barplot(res5$P[3,])
alpha2 <- alphaNR(t(BRCA21),3, patient_specific = T)
hist(alpha2, breaks = 1000, xlim=c(0,1000))
hist(alpha2, breaks = 1000)
length(alpha2)
res5 <- NMFNB(t(BRCA21),3, alpha2)
par(mfrow=c(2,2))
barplot(res5$P[1,])
barplot(res5$P[2,])
barplot(res5$P[3,])
barplot(res2$Signatures[1,])
barplot(res2$Signatures[2,])
barplot(res2$Signatures[3,])
res6 <-  sigmos(t(BRCA21),k=3,method = "NB", patient_specific = T)
par(mfrow=c(2,2))
barplot(res6$Signatures[1,])
barplot(res6$Signatures[2,])
barplot(res6$Signatures[3,])
remove.packages("SigMoS", lib="~/R/x86_64-pc-linux-gnu-library/4.2")
setwd("/home/au687642/Documents/Postdoc/NegBin/SigMoS/data")
rm(list=ls())
